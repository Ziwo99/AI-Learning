<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>AI-Learning - PYTHON Section 9</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="/assets/css/main.css" />
	<noscript>
		<link rel="stylesheet" href="/assets/css/noscript.css" />
	</noscript>
</head>

<body class="is-preload">

	<!-- Page Wrapper -->
	<div id="page-wrapper">

		<!-- Header -->
		<header id="header" class="alt" style="display: flex; align-items: center;">
			<a href="index.html" style="text-decoration: none; border: none; outline: none;">
				<img src="images/logo_small.svg" alt="Votre Logo" style="display: block; border: none;">
			</a>
			<nav>
				<a href="#menu">Menu</a>
			</nav>
		</header>

		<!-- Menu -->
		<nav id="menu">
			<div class="inner">
				<h2>Menu</h2>
				<ul class="links">
					<li><a href="index.html">Accueil</a></li>
					<li><a href="#">Formations</a></li>
					<li><a href="#">Qu'est ce qu'AI-Learning ?</a></li>
					<li><a href="#">Comment sont générer nos formations ?</a></li>
					<li><a href="#">Travail de recherche</a></li>
				</ul>
				<a href="#" class="close">Close</a>
			</div>
		</nav>

		<!-- Wrapper -->
		<section id="wrapper">
			<header>
				<div class="inner">
					<h2>Section 3 : Programmation orientée objet en Kotlin</h2>
				</div>
			</header>

			<!-- Content -->
			<div class="wrapper">
				<div class="inner">
					<h1>Section 3 : Programmation orientée objet en Kotlin</h1>

<h2>Classes et objets</h2>
<p>Les classes et objets sont les éléments fondamentaux de la programmation orientée objet en Kotlin. Une classe est un modèle ou un plan pour créer des objets, qui sont des instances de cette classe. Les objets sont utilisés pour encapsuler des données et des fonctionnalités connexes.</p>

<p>Voici un exemple de déclaration de classe en Kotlin :</p>

<pre><code>class Person(val name: String, var age: Int) {
    fun speak() {
        println("Hello, my name is $name.")
    }
}</code></pre>

<p>Dans cet exemple, nous avons déclaré une classe "Person" avec deux propriétés : "name" (en lecture seule) et "age" (modifiable). La classe a également une fonction "speak" qui imprime un message de salutation avec le nom de la personne.</p>

<p>Pour créer une instance de cette classe, nous utilisons le mot-clé "val" ou "var" suivi du nom de la classe et des arguments nécessaires :</p>

<pre><code>val person = Person("John", 25)</code></pre>

<p>Nous pouvons ensuite accéder aux propriétés et aux fonctions de l'objet "person" :</p>

<pre><code>println(person.name) // Output: John
person.age = 26
person.speak() // Output: Hello, my name is John.</code></pre>

<h2>Héritage et polymorphisme</h2>
<p>L'héritage permet de créer de nouvelles classes basées sur des classes existantes. La classe héritante (ou sous-classe) hérite des propriétés et des fonctions de la classe parente (ou superclasse). Le polymorphisme permet à une classe d'être utilisée comme une instance de sa classe parente ou de l'une de ses sous-classes.</p>

<p>Voici un exemple d'héritage en Kotlin :</p>

<pre><code>open class Animal(val name: String) {
    open fun makeSound() {
        println("The animal makes a sound.")
    }
}

class Dog(name: String) : Animal(name) {
    override fun makeSound() {
        println("The dog barks.")
    }
}</code></pre>

<p>Dans cet exemple, nous avons une classe "Animal" avec une propriété "name" et une fonction "makeSound". La classe "Dog" hérite de la classe "Animal" et remplace la fonction "makeSound" pour spécifier le son d'un chien.</p>

<p>Nous pouvons créer une instance de la classe "Dog" et l'utiliser comme une instance de la classe "Animal" :</p>

<pre><code>val animal: Animal = Dog("Buddy")
animal.makeSound() // Output: The dog barks.</code></pre>

<h2>Interfaces</h2>
<p>Les interfaces définissent un contrat pour les classes qui les implémentent. Une classe peut implémenter plusieurs interfaces, ce qui lui permet de fournir des fonctionnalités spécifiques à chaque interface.</p>

<p>Voici un exemple d'interface en Kotlin :</p>

<pre><code>interface Drawable {
    fun draw()
}

class Circle : Drawable {
    override fun draw() {
        println("Drawing a circle.")
    }
}

class Square : Drawable {
    override fun draw() {
        println("Drawing a square.")
    }
}</code></pre>

<p>Dans cet exemple, nous avons une interface "Drawable" avec une fonction "draw". Les classes "Circle" et "Square" implémentent cette interface et fournissent une implémentation spécifique de la fonction "draw".</p>

<p>Nous pouvons créer des instances de ces classes et les utiliser comme des instances de l'interface "Drawable" :</p>

<pre><code>val circle: Drawable = Circle()
val square: Drawable = Square()

circle.draw() // Output: Drawing a circle.
square.draw() // Output: Drawing a square.</code></pre>

<h2>Extensions</h2>
<p>Les extensions permettent d'ajouter de nouvelles fonctionnalités à des classes existantes sans les modifier. Cela permet d'étendre les fonctionnalités d'une classe sans avoir à la sous-classer ou à modifier son code source.</p>

<p>Voici un exemple d'extension en Kotlin :</p>

<pre><code>fun String.isPalindrome(): Boolean {
    val reversed = this.reversed()
    return this == reversed
}

val word = "radar"
println(word.isPalindrome()) // Output: true</code></pre>

<p>Dans cet exemple, nous avons ajouté une extension à la classe "String" pour vérifier si une chaîne de caractères est un palindrome. Nous pouvons ensuite utiliser cette extension sur n'importe quelle instance de la classe "String".</p>

<h2>Gestion des exceptions</h2>
<p>La gestion des exceptions permet de gérer les erreurs et les situations exceptionnelles qui peuvent se produire pendant l'exécution d'un programme. Kotlin fournit des mécanismes pour capturer, lancer et gérer les exceptions.</p>

<p>Voici un exemple de gestion des exceptions en Kotlin :</p>

<pre><code>fun divide(a: Int, b: Int): Int {
    if (b == 0) {
        throw IllegalArgumentException("Divisor cannot be zero.")
    }
    return a / b
}

try {
    val result = divide(10, 0)
    println(result)
} catch (e: Exception) {
    println("An error occurred: ${e.message}")
}</code></pre>

<p>Dans cet exemple, nous avons une fonction "divide" qui effectue une division. Si le diviseur est zéro, nous lançons une exception avec un message d'erreur. Nous utilisons ensuite un bloc "try-catch" pour capturer l'exception et afficher un message d'erreur approprié.</p>

<p>Il est important de gérer les exceptions de manière appropriée pour éviter les plantages du programme et fournir des informations utiles aux utilisateurs.</p>
				</div>
			</div>

		</section>

		<!-- Footer -->
		<section id="footer">
			<div class="inner">
				<ul class="copyright">
					<li>&copy; Untitled Inc. All rights reserved.</li>
					<li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
				</ul>
			</div>
		</section>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.scrollex.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>


</body>

</html>