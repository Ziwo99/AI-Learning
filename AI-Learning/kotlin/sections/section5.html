<!DOCTYPE HTML>
<!--
	Solid State by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>

<head>
	<title>AI-Learning - PYTHON Section 9</title>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="/assets/css/main.css" />
	<noscript>
		<link rel="stylesheet" href="/assets/css/noscript.css" />
	</noscript>
</head>

<body class="is-preload">

	<!-- Page Wrapper -->
	<div id="page-wrapper">

		<!-- Header -->
		<header id="header" class="alt" style="display: flex; align-items: center;">
			<a href="index.html" style="text-decoration: none; border: none; outline: none;">
				<img src="images/logo_small.svg" alt="Votre Logo" style="display: block; border: none;">
			</a>
			<nav>
				<a href="#menu">Menu</a>
			</nav>
		</header>

		<!-- Menu -->
		<nav id="menu">
			<div class="inner">
				<h2>Menu</h2>
				<ul class="links">
					<li><a href="index.html">Accueil</a></li>
					<li><a href="#">Formations</a></li>
					<li><a href="#">Qu'est ce qu'AI-Learning ?</a></li>
					<li><a href="#">Comment sont générer nos formations ?</a></li>
					<li><a href="#">Travail de recherche</a></li>
				</ul>
				<a href="#" class="close">Close</a>
			</div>
		</nav>

		<!-- Wrapper -->
		<section id="wrapper">
			<header>
				<div class="inner">
					<h2>Section 5 : Programmation asynchrone en Kotlin</h2>
				</div>
			</header>

			<!-- Content -->
			<div class="wrapper">
				<div class="inner">
					<h1>Section 5: Programmation asynchrone en Kotlin</h1>

<h2>Introduction aux coroutines</h2>
<p>Les coroutines sont un moyen efficace de gérer la programmation asynchrone en Kotlin. Elles permettent d'exécuter des tâches de manière concurrente sans bloquer le thread principal. Les coroutines sont légères et peuvent être utilisées pour effectuer des opérations longues ou des appels réseau sans ralentir l'application.</p>

<p>Voici un exemple de création d'une coroutine :</p>

<pre><code>import kotlinx.coroutines.*

fun main() {
    GlobalScope.launch {
        delay(1000)
        println("Coroutine executed after delay")
    }
    println("Main thread continues")
    Thread.sleep(2000)
}
</code></pre>

<p>Dans cet exemple, une coroutine est créée à l'aide de la fonction <code>launch</code> de <code>GlobalScope</code>. La coroutine effectue une pause de 1000 millisecondes à l'aide de la fonction <code>delay</code> de <code>kotlinx.coroutines</code> puis affiche un message. Pendant ce temps, le thread principal continue son exécution.</p>

<h2>Utilisation des coroutines pour la programmation asynchrone</h2>
<p>Les coroutines offrent une syntaxe simplifiée pour gérer la programmation asynchrone. Elles permettent d'effectuer des opérations longues de manière asynchrone sans bloquer le thread principal.</p>

<p>Voici un exemple d'utilisation des coroutines pour effectuer une requête réseau :</p>

<pre><code>import kotlinx.coroutines.*
import java.net.URL

fun main() {
    GlobalScope.launch {
        val result = async { fetchDataFromNetwork() }
        val data = result.await()
        println("Data received: $data")
    }
    println("Main thread continues")
    Thread.sleep(2000)
}

suspend fun fetchDataFromNetwork(): String {
    delay(1000)
    return URL("https://example.com").readText()
}
</code></pre>

<p>Dans cet exemple, une coroutine est créée à l'aide de la fonction <code>launch</code> de <code>GlobalScope</code>. À l'intérieur de cette coroutine, une autre coroutine est créée à l'aide de la fonction <code>async</code>. Cette coroutine effectue une requête réseau à l'aide de la fonction <code>fetchDataFromNetwork</code> et retourne les données. La fonction <code>await</code> est utilisée pour attendre la fin de l'exécution de la coroutine et récupérer le résultat.</p>

<h2>Gestion des threads et de la concurrence</h2>
<p>Les coroutines permettent de gérer facilement la concurrence et la gestion des threads. Kotlin fournit des coroutines de manière native, ce qui facilite la gestion des threads et évite les problèmes de synchronisation.</p>

<p>Voici un exemple de gestion des threads avec les coroutines :</p>

<pre><code>import kotlinx.coroutines.*

fun main() {
    runBlocking {
        val job1 = launch {
            repeat(5) {
                delay(100)
                println("Job 1: $it")
            }
        }
        val job2 = launch {
            repeat(5) {
                delay(200)
                println("Job 2: $it")
            }
        }
        job1.join()
        job2.join()
    }
}
</code></pre>

<p>Dans cet exemple, deux coroutines sont créées à l'aide de la fonction <code>launch</code> à l'intérieur d'un bloc <code>runBlocking</code>. Chaque coroutine effectue une boucle répétée avec un délai différent. Les coroutines s'exécutent de manière concurrente et les résultats sont affichés dans la console.</p>

<p>En utilisant les coroutines, la gestion des threads devient plus simple et plus intuitive, évitant ainsi les problèmes de concurrence et de synchronisation.</p>
				</div>
			</div>

		</section>

		<!-- Footer -->
		<section id="footer">
			<div class="inner">
				<ul class="copyright">
					<li>&copy; Untitled Inc. All rights reserved.</li>
					<li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
				</ul>
			</div>
		</section>

	</div>

	<!-- Scripts -->
	<script src="assets/js/jquery.min.js"></script>
	<script src="assets/js/jquery.scrollex.min.js"></script>
	<script src="assets/js/browser.min.js"></script>
	<script src="assets/js/breakpoints.min.js"></script>
	<script src="assets/js/util.js"></script>
	<script src="assets/js/main.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js"></script>
	<script>hljs.highlightAll();</script>


</body>

</html>